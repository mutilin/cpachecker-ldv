/*
 * JNI wrapper implementation automatically generated by extract_java_stub.py
 */
#include <stdlib.h>
#include <jni.h>

#include "mathsat.h"

// helper definitions

#define CHECK_FOR_NULL(var) \
  if (var == NULL) { \
    return 0; \
  }

typedef void jvoid; // for symmetry to jint, jlong etc.

// Macros for defining JNI functions which call Mathsat
// Use them as follows:
//
// DEFINE_FUNC(java_return_type, escaped_name_without_msat) WITH_X_ARGS(java_arg_types)
// for each arg a definition like STRUCT_ARG(msat_arg_type, position)
// CALLX(msat_return_type, function_name_without_msat)
// return definition like STRUCT_RETURN depending on the return type

#define DEFINE_FUNC(jreturn, func_escaped) \
  JNIEXPORT j##jreturn JNICALL Java_org_sosy_1lab_cpachecker_util_predicates_mathsat_NativeApi_msat_##func_escaped

#define WITHOUT_ARGS \
  (JNIEnv *jenv, jclass jcls) {

#define WITH_ONE_ARG(jtype) \
  (JNIEnv *jenv, jclass jcls, j##jtype arg1) {

#define WITH_TWO_ARGS(jtype1, jtype2) \
  (JNIEnv *jenv, jclass jcls, j##jtype1 arg1, j##jtype2 arg2) {

#define WITH_THREE_ARGS(jtype1, jtype2, jtype3) \
  (JNIEnv *jenv, jclass jcls, j##jtype1 arg1, j##jtype2 arg2, j##jtype3 arg3) {

#define WITH_FOUR_ARGS(jtype1, jtype2, jtype3, jtype4) \
  (JNIEnv *jenv, jclass jcls, j##jtype1 arg1, j##jtype2 arg2, j##jtype3 arg3, j##jtype4 arg4) {

#define WITH_FIVE_ARGS(jtype1, jtype2, jtype3, jtype4, jtype5) \
  (JNIEnv *jenv, jclass jcls, j##jtype1 arg1, j##jtype2 arg2, j##jtype3 arg3, j##jtype4 arg4, j##jtype5 arg5) {


#define SIMPLE_ARG(mtype, num) \
  mtype m_arg##num = arg##num;

#define STRUCT_ARG(mtype, num) \
  mtype m_arg##num; \
  m_arg##num.repr = (void *)((size_t)arg##num);

#define STRING_ARG(num) \
  char * m_arg##num; \
  m_arg##num = (char *)(*jenv)->GetStringUTFChars(jenv, arg##num, NULL); \
  CHECK_FOR_NULL(m_arg##num)

#define STRUCT_ARRAY_ARG(mtype, num) \
  mtype * m_arg##num; \
  { \
    jlong *tmp = (jlong *)((*jenv)->GetLongArrayElements(jenv, arg##num, NULL)); \
    CHECK_FOR_NULL(tmp) \
    size_t sz = (size_t)((*jenv)->GetArrayLength(jenv, arg##num)); \
    m_arg##num = (mtype *)malloc(sizeof(mtype) * sz); \
    size_t i; \
    for (i = 0; i < sz; ++i) { \
       m_arg##num[i].repr = (void *)((size_t)tmp[i]); \
    } \
    (*jenv)->ReleaseLongArrayElements(jenv, arg##num, tmp, 0); \
  }

#define STRUCT_POINTER_ARG(mtype, num) \
  mtype s_arg##num; \
  mtype * m_arg##num = &s_arg##num;

#define INT_ARRAY_ARG(num) \
  int * m_arg##num = (int *)((*jenv)->GetIntArrayElements(jenv, arg##num, NULL)); \
  CHECK_FOR_NULL(m_arg##num)

#define STRUCT_ARRAY_OUTPUT_ARG(mtype, num) \
  mtype *p_arg##num = NULL; \
  mtype ** m_arg##num = &p_arg##num;


#define CALL0(mreturn, func) mreturn retval = msat_##func();
#define CALL1(mreturn, func) mreturn retval = msat_##func(m_arg1);
#define CALL2(mreturn, func) mreturn retval = msat_##func(m_arg1, m_arg2);
#define CALL3(mreturn, func) mreturn retval = msat_##func(m_arg1, m_arg2, m_arg3);
#define CALL4(mreturn, func) mreturn retval = msat_##func(m_arg1, m_arg2, m_arg3, m_arg4);
#define CALL5(mreturn, func) mreturn retval = msat_##func(m_arg1, m_arg2, m_arg3, m_arg4, m_arg5);
#define VOID_CALL1(func) msat_##func(m_arg1); }


#define FREE_STRING_ARG(num) \
  (*jenv)->ReleaseStringUTFChars(jenv, arg##num, m_arg##num);

#define FREE_STRUCT_ARRAY_ARG(num) \
  free(m_arg##num);

#define FREE_INT_ARRAY_ARG(num) \
  (*jenv)->ReleaseIntArrayElements(jenv, arg##num, m_arg##num, 0);

#define PUT_STRUCT_POINTER_ARG(num) \
  (*jenv)->SetLongArrayRegion(jenv, arg##num, 0, 1, (jlong *)&(s_arg##num.repr));

#define STRUCT_RETURN \
  return (jlong)((size_t)(retval.repr)); \
}

#define INT_RETURN \
  return (jint)retval; \
}

#define STRING_RETURN \
  jstring jretval = (*jenv)->NewStringUTF(jenv, retval); \
  free(retval); \
  return jretval; \
}

#define RETURN_STRUCT_ARRAY(arg_num) \
  jlongArray jretval; \
  if (retval > 0) { \
    jlong *jarr = malloc(sizeof(jlong) * (size_t)retval); \
    int i; \
    for (i = 0; i < (size_t)retval; ++i) { \
        jarr[i] = (jlong)((size_t)p_arg##arg_num[i].repr); \
    } \
    jretval = (*jenv)->NewLongArray(jenv, (size_t)retval); \
    (*jenv)->SetLongArrayRegion(jenv, jretval, 0, (size_t)retval, jarr); \
    free(jarr); \
  } else { \
    jretval = (*jenv)->NewLongArray(jenv, 0); \
  } \
  \
  if (p_arg##arg_num) { \
    free(p_arg##arg_num); \
  } \
  \
  return jretval; \
}


// Define aliases for Mathsats types
typedef jlong jjenv;
#define ENV_ARG(num) STRUCT_ARG(msat_env, num)
#define ENV_RETURN STRUCT_RETURN

typedef jlong jjterm;
#define TERM_ARG(num) STRUCT_ARG(msat_term, num)
#define TERM_RETURN STRUCT_RETURN
typedef jlongArray jjtermArray;
#define TERM_ARRAY_ARG(num) STRUCT_ARRAY_ARG(msat_term, num)
#define FREE_TERM_ARRAY_ARG(num) FREE_STRUCT_ARRAY_ARG(num)
#define TERM_ARRAY_OUTPUT_ARG(num) STRUCT_ARRAY_OUTPUT_ARG(msat_term, num)
#define RETURN_TERM_ARRAY(arg_num) RETURN_STRUCT_ARRAY(arg_num)
#define TERM_POINTER_ARG(num) STRUCT_POINTER_ARG(msat_term, num)
#define PUT_TERM_POINTER_ARG(num) PUT_STRUCT_POINTER_ARG(num)

typedef jlong jjdecl;
#define DECL_ARG(num) STRUCT_ARG(msat_decl, num)
#define DECL_RETURN STRUCT_RETURN

typedef jlong jjmodel_iterator;
#define MODEL_ITERATOR_ARG(num) STRUCT_ARG(msat_model_iterator, num)
#define MODEL_ITERATOR_RETURN STRUCT_RETURN

typedef jint jjtype;
#define TYPE_ARG(num) SIMPLE_ARG(msat_type, num)
#define TYPE_RETURN INT_RETURN


// Abbreviations for common combinations of return and argument types
//
// Parameter explanation:
// func: the name of the Mathsat function (without msat_)
// func_escaped: the escaped variant of func
// jreturn: return type in Java world
// mreturn: return type of Mathsat C function
// margX: Java type of argument X
// jargX: Mathsat type of argument X

#define i_func1s(func, func_escaped, mreturn, marg1) \
  DEFINE_FUNC(int, func_escaped) WITH_ONE_ARG(long) \
  STRUCT_ARG(marg1, 1) \
  CALL1(mreturn, func) \
  INT_RETURN

#define s_func1s(func, func_escaped, mreturn, marg1) \
  DEFINE_FUNC(long, func_escaped) WITH_ONE_ARG(long) \
  STRUCT_ARG(marg1, 1) \
  CALL1(mreturn, func) \
  STRUCT_RETURN

#define i_func1t(func, func_escaped) \
	i_func1s(func, func_escaped, \
		int, \
		msat_term)


#define i_func2si(func, func_escaped, mreturn, marg1, marg2) \
  DEFINE_FUNC(int, func_escaped) WITH_TWO_ARGS(long, int) \
  STRUCT_ARG(marg1, 1) \
  SIMPLE_ARG(marg2, 2) \
  CALL2(mreturn, func) \
  INT_RETURN

#define s_func2ss(func, func_escaped, mreturn, marg1, marg2) \
  DEFINE_FUNC(long, func_escaped) WITH_TWO_ARGS(long, long) \
  STRUCT_ARG(marg1, 1) \
  STRUCT_ARG(marg2, 2) \
  CALL2(mreturn, func) \
  STRUCT_RETURN


#define term_to_string(func, func_escaped) \
  DEFINE_FUNC(string, func_escaped) WITH_TWO_ARGS(jenv, jterm) \
  ENV_ARG(1) \
  TERM_ARG(2) \
  CALL2(char *, func) \
  STRING_RETURN

#define make_term_from_string(func, func_escaped) \
  DEFINE_FUNC(jterm, func_escaped) WITH_TWO_ARGS(jenv, string) \
  ENV_ARG(1) \
  STRING_ARG(2) \
  CALL2(msat_term, func) \
  FREE_STRING_ARG(2) \
  TERM_RETURN


// Now really define the functions.

struct j_msat_all_sat_helper {
   JNIEnv *jenv;
   jobject obj;
};

static void call_java_callback(msat_term *model, int size, void *user_data)
{
    struct j_msat_all_sat_helper *helper =
        (struct j_msat_all_sat_helper *)user_data;

    const char *signature = "([J)V";
    jclass cls = (*(helper->jenv))->FindClass(helper->jenv,
                                              "org/sosy_lab/cpachecker/util/predicates/mathsat/NativeApi$AllSatModelCallback");
    jmethodID mid = (*(helper->jenv))->GetMethodID(helper->jenv, cls,
                                                   "callback", signature);    
        
    jlongArray jmodel = (*(helper->jenv))->NewLongArray(helper->jenv,
                                                        (size_t)size);
    jlong *jarr = malloc(sizeof(jlong) * size);
    int i;
    for (i = 0; i < size; ++i) {
        jarr[i] = (jlong)((size_t)model[i].repr);
    }
    (*(helper->jenv))->SetLongArrayRegion(helper->jenv, jmodel, 0, (size_t)size,
                                          (jlong *)jarr);

    (*(helper->jenv))->CallVoidMethod(helper->jenv, helper->obj, mid, jmodel);
    free(jarr);
}


DEFINE_FUNC(void, 1set_1verbosity) WITH_ONE_ARG(int)
SIMPLE_ARG(int, 1)
VOID_CALL1(set_verbosity)


DEFINE_FUNC(jenv, 1create_1env) WITHOUT_ARGS
CALL0(msat_env, create_env)
ENV_RETURN


s_func1s(create_shared_env, 1create_1shared_1env, \
	msat_env, \
	msat_env)


DEFINE_FUNC(void, 1reset_1env) WITH_ONE_ARG(jenv) \
ENV_ARG(1) \
VOID_CALL1(reset_env)


DEFINE_FUNC(void, 1destroy_1env) WITH_ONE_ARG(jenv) \
ENV_ARG(1) \
VOID_CALL1(destroy_env)


DEFINE_FUNC(int, 1set_1option) WITH_THREE_ARGS(jenv, string, string)
ENV_ARG(1)
STRING_ARG(2)
STRING_ARG(3)
CALL3(int, set_option)
FREE_STRING_ARG(3)
FREE_STRING_ARG(2)
INT_RETURN


DEFINE_FUNC(jdecl, 1declare_1variable) WITH_THREE_ARGS(jenv, string, jtype)
ENV_ARG(1)
STRING_ARG(2)
TYPE_ARG(3)
CALL3(msat_decl, declare_variable)
FREE_STRING_ARG(2)
DECL_RETURN


DEFINE_FUNC(jdecl, 1declare_1uif) WITH_FIVE_ARGS(jenv, string, jtype, int, intArray)
ENV_ARG(1)
STRING_ARG(2)
TYPE_ARG(3)
SIMPLE_ARG(int, 4)
INT_ARRAY_ARG(5)
CALL5(msat_decl, declare_uif)
FREE_INT_ARRAY_ARG(5)
FREE_STRING_ARG(2)
DECL_RETURN


s_func1s(make_true, 1make_1true, \
	msat_term, \
	msat_env)

s_func1s(make_false, 1make_1false, \
	msat_term, \
	msat_env)

#define make_term_binary(name) \
  DEFINE_FUNC(jterm, 1make_1##name) WITH_THREE_ARGS(jenv, jterm, jterm) \
  ENV_ARG(1) \
  TERM_ARG(2) \
  TERM_ARG(3) \
  CALL3(msat_term, make_##name) \
  TERM_RETURN

make_term_binary(iff)
make_term_binary(implies)
make_term_binary(or)
make_term_binary(xor)

s_func2ss(make_not, 1make_1not, \
	msat_term, \
	msat_env, \
	msat_term)

make_term_binary(and)
make_term_binary(equal)
make_term_binary(lt)
make_term_binary(gt)
make_term_binary(leq)
make_term_binary(geq)
make_term_binary(plus)
make_term_binary(minus)
make_term_binary(times)

s_func2ss(make_negate, 1make_1negate, \
	msat_term, \
	msat_env, \
	msat_term)

make_term_from_string(make_number, 1make_1number)


DEFINE_FUNC(jterm, 1make_1ite) WITH_FOUR_ARGS(jenv, jterm, jterm, jterm)
ENV_ARG(1)
TERM_ARG(2)
TERM_ARG(3)
TERM_ARG(4)
CALL4(msat_term, make_ite)
TERM_RETURN


s_func2ss(make_variable, 1make_1variable, \
	msat_term, \
	msat_env, \
	msat_decl)


DEFINE_FUNC(jterm, 1make_1uif) WITH_THREE_ARGS(jenv, jdecl, jtermArray)
ENV_ARG(1)
DECL_ARG(2)
TERM_ARRAY_ARG(3)
CALL3(msat_term, make_uif)
FREE_TERM_ARRAY_ARG(3)
TERM_RETURN


#define make_term_bv_binary(name) \
  DEFINE_FUNC(jterm, 1make_1bv_1##name) WITH_THREE_ARGS(jenv, jterm, jterm) \
  ENV_ARG(1) \
  TERM_ARG(2) \
  TERM_ARG(3) \
  CALL3(msat_term, make_bv_##name) \
  TERM_RETURN

make_term_bv_binary(concat)
make_term_bv_binary(or)
make_term_bv_binary(xor)
make_term_bv_binary(and)
make_term_bv_binary(lsl)
make_term_bv_binary(lsr)
make_term_bv_binary(asr)
make_term_bv_binary(plus)
make_term_bv_binary(minus)
make_term_bv_binary(times)
make_term_bv_binary(udiv)
make_term_bv_binary(urem)
make_term_bv_binary(sdiv)
make_term_bv_binary(srem)
make_term_bv_binary(smod)
make_term_bv_binary(ult)
make_term_bv_binary(uleq)
make_term_bv_binary(ugt)
make_term_bv_binary(ugeq)
make_term_bv_binary(slt)
make_term_bv_binary(sleq)
make_term_bv_binary(sgt)
make_term_bv_binary(sgeq)

make_term_from_string(from_string, 1from_1string)


DEFINE_FUNC(jterm, 1from_1string_1and_1name) WITH_THREE_ARGS(jenv, string, string)
ENV_ARG(1)
STRING_ARG(2)
STRING_ARG(3)
CALL3(msat_term, from_string_and_name)
FREE_STRING_ARG(3)
FREE_STRING_ARG(2)
TERM_RETURN


DEFINE_FUNC(jterm, 1make_1copy_1from) WITH_THREE_ARGS(jenv, jterm, jenv) \
ENV_ARG(1) \
TERM_ARG(2) \
ENV_ARG(3) \
CALL3(msat_term, make_copy_from) \
TERM_RETURN


DEFINE_FUNC(jterm, 1replace_1args) WITH_THREE_ARGS(jenv, jterm, jtermArray)
ENV_ARG(1)
TERM_ARG(2)
TERM_ARRAY_ARG(3)
CALL3(msat_term, replace_args)
FREE_TERM_ARRAY_ARG(3)
TERM_RETURN


make_term_from_string(from_msat, 1from_1msat)
make_term_from_string(from_smt, 1from_1smt)
make_term_from_string(from_foci, 1from_1foci)

term_to_string(to_msat, 1to_1msat)
term_to_string(to_smtlib, 1to_1smtlib)

i_func1t(term_id, 1term_1id)
i_func1t(term_arity, 1term_1arity)


DEFINE_FUNC(jterm, 1term_1get_1arg) WITH_TWO_ARGS(jterm, int) \
TERM_ARG(1) \
SIMPLE_ARG(int, 2) \
CALL2(msat_term, term_get_arg) \
TERM_RETURN


i_func1t(term_get_type, 1term_1get_1type)

#define func_term_is(name) i_func1t(term_is_##name, 1term_1is_1##name)
func_term_is(true)
func_term_is(false)
i_func1t(term_is_boolean_var, 1term_1is_1boolean_1var)
func_term_is(atom)
func_term_is(number)
func_term_is(and)
func_term_is(or)
func_term_is(not)
func_term_is(iff)
func_term_is(implies)
func_term_is(xor)
i_func1t(term_is_bool_ite, 1term_1is_1bool_1ite)
i_func1t(term_is_term_ite, 1term_1is_1term_1ite)
func_term_is(variable)
func_term_is(uif)
func_term_is(equal)
func_term_is(lt)
func_term_is(leq)
func_term_is(gt)
func_term_is(geq)
func_term_is(plus)
func_term_is(minus)
func_term_is(times)
func_term_is(negate)

#define func_term_is_bv(name) i_func1t(term_is_bv_##name, 1term_1is_1bv_1##name)
func_term_is_bv(concat)
func_term_is_bv(select)
func_term_is_bv(or)
func_term_is_bv(xor)
func_term_is_bv(and)
func_term_is_bv(not)
func_term_is_bv(lsl)
func_term_is_bv(lsr)
func_term_is_bv(asr)
func_term_is_bv(zext)
func_term_is_bv(sext)
func_term_is_bv(plus)
func_term_is_bv(minus)
func_term_is_bv(times)
func_term_is_bv(udiv)
func_term_is_bv(urem)
func_term_is_bv(sdiv)
func_term_is_bv(srem)
func_term_is_bv(smod)
func_term_is_bv(ult)
func_term_is_bv(uleq)
func_term_is_bv(ugt)
func_term_is_bv(ugeq)
func_term_is_bv(slt)
func_term_is_bv(sleq)
func_term_is_bv(sgt)
func_term_is_bv(sgeq)

s_func1s(term_get_decl, 1term_1get_1decl, \
	msat_decl, \
	msat_term)


DEFINE_FUNC(jtype, 1decl_1get_1return_1type) WITH_ONE_ARG(jdecl) \
DECL_ARG(1) \
CALL1(msat_type, decl_get_return_type) \
TYPE_RETURN


i_func1s(decl_get_arity, 1decl_1get_1arity, \
	int,
	msat_decl)


DEFINE_FUNC(jtype, 1decl_1get_1arg_1type) WITH_TWO_ARGS(jdecl, int) \
DECL_ARG(1) \
SIMPLE_ARG(int, 2) \
CALL2(msat_type, decl_get_arg_type) \
TYPE_RETURN


DEFINE_FUNC(string, 1decl_1get_1name) WITH_ONE_ARG(jdecl) \
DECL_ARG(1) \
CALL1(char *, decl_get_name) \
STRING_RETURN


term_to_string(term_get_name, 1term_1get_1name)


DEFINE_FUNC(string, 1term_1repr) WITH_ONE_ARG(jterm) \
TERM_ARG(1) \
CALL1(char *, term_repr) \
STRING_RETURN


i_func2si(add_theory, 1add_1theory, \
	int, \
	msat_env, \
	msat_theory)

i_func2si(set_theory_combination, 1set_1theory_1combination, \
	int, \
	msat_env, \
	msat_theory_combination)

i_func1s(push_backtrack_point, 1push_1backtrack_1point, \
	int, \
	msat_env)

i_func1s(pop_backtrack_point, 1pop_1backtrack_1point, \
	int, \
	msat_env)


DEFINE_FUNC(int, 1assert_1formula) WITH_TWO_ARGS(jenv, jterm) \
ENV_ARG(1) \
TERM_ARG(2)
CALL2(int, assert_formula) \
INT_RETURN


i_func1s(solve, 1solve, \
	msat_result, \
	msat_env)


DEFINE_FUNC(int, 1all_1sat) WITH_FIVE_ARGS(jenv, jtermArray, int, object, int)
ENV_ARG(1)
TERM_ARRAY_ARG(2)
SIMPLE_ARG(int, 3)
    struct j_msat_all_sat_helper helper = {jenv, arg4};
    int retval = msat_all_sat(m_arg1, m_arg2, m_arg3, call_java_callback, &helper);
FREE_TERM_ARRAY_ARG(2)
INT_RETURN


s_func2ss(get_model_value, 1get_1model_1value, \
	msat_term, \
	msat_env, \
	msat_term)

s_func1s(create_model_iterator, 1create_1model_1iterator, \
	msat_model_iterator, \
	msat_env)

i_func1s(model_iterator_has_next, 1model_1iterator_1has_1next, \
	int, \
	msat_model_iterator)


DEFINE_FUNC(int, 1model_1iterator_1next) WITH_THREE_ARGS(jmodel_iterator, jtermArray, jtermArray)
MODEL_ITERATOR_ARG(1)
TERM_POINTER_ARG(2)
TERM_POINTER_ARG(3)
CALL3(int, model_iterator_next)
PUT_TERM_POINTER_ARG(3)
PUT_TERM_POINTER_ARG(2)
INT_RETURN


DEFINE_FUNC(void, 1destroy_1model_1iterator) WITH_ONE_ARG(jmodel_iterator)
MODEL_ITERATOR_ARG(1)
VOID_CALL1(destroy_model_iterator)


DEFINE_FUNC(jtermArray, 1get_1theory_1lemmas) WITH_TWO_ARGS(jenv, int)
ENV_ARG(1)
TERM_ARRAY_OUTPUT_ARG(2)
CALL2(int, get_theory_lemmas)
RETURN_TERM_ARRAY(2)

s_func1s(get_unsat_core, 1get_1unsat_1core, \
	msat_term, \
	msat_env)

i_func1s(init_interpolation, 1init_1interpolation, \
	int,
	msat_env)

i_func1s(create_itp_group, 1create_1itp_1group, \
	int,
	msat_env)

i_func2si(set_itp_group, 1set_1itp_1group, \
	int, \
	msat_env, \
	int)

DEFINE_FUNC(jterm, 1get_1interpolant) WITH_THREE_ARGS(jenv, intArray, int)
ENV_ARG(1)
INT_ARRAY_ARG(2)
SIMPLE_ARG(size_t, 3)
CALL3(msat_term, get_interpolant)
FREE_INT_ARRAY_ARG(2)
TERM_RETURN
