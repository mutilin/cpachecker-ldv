/* Generated by CIL v. 1.3.7 */
/* print_CIL_Input is true */

#line 13 "rule57_ebda_blast-2_BUG.c"
struct hotplug_slot;
#line 13
struct hotplug_slot;
#line 15 "rule57_ebda_blast-2_BUG.c"
struct bus_info {

};
#line 18 "rule57_ebda_blast-2_BUG.c"
struct slot {
   int a ;
   int b ;
   struct hotplug_slot *hotplug_slot ;
   struct bus_info *bus_on ;
};
#line 25 "rule57_ebda_blast-2_BUG.c"
struct hotplug_slot {
   struct slot *private ;
   int b ;
};
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void __assert_fail(char const   *__assertion ,
                                                                      char const   *__file ,
                                                                      unsigned int __line ,
                                                                      char const   *__function ) ;
#line 9 "rule57_ebda_blast-2_BUG.c"
int VERDICT_UNSAFE  ;
#line 10 "rule57_ebda_blast-2_BUG.c"
int CURRENTLY_UNSAFE  ;
#line 35 "rule57_ebda_blast-2_BUG.c"
struct slot *tmp_slot  ;
#line 36 "rule57_ebda_blast-2_BUG.c"
int used_tmp_slot  =    0;
#line 37 "rule57_ebda_blast-2_BUG.c"
int freed_tmp_slot  =    1;
#line 39
extern void *kzalloc(int  , int  ) ;
#line 41 "rule57_ebda_blast-2_BUG.c"
void kfree(void *p ) 
{ 

  {
#line 42
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 42
    if ((unsigned long )p == (unsigned long )tmp_slot) {
#line 43
      freed_tmp_slot = 1;
    } else {

    }
  } else {

  }
#line 44
  return;
}
}
#line 46
extern struct bus_info *ibmphp_find_same_bus_num() ;
#line 48
extern int fillslotinfo(struct hotplug_slot * ) ;
#line 49
extern int ibmphp_init_devno(struct slot ** ) ;
#line 51 "rule57_ebda_blast-2_BUG.c"
int ebda_rsrc_controller(void) 
{ struct hotplug_slot *hp_slot_ptr ;
  struct bus_info *bus_info_ptr1 ;
  int rc ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 57
  tmp = kzalloc((int )sizeof(*hp_slot_ptr), 1);
#line 57
  hp_slot_ptr = (struct hotplug_slot *)tmp;
  }
#line 58
  if (! hp_slot_ptr) {
#line 59
    rc = -2;
    goto error_no_slot;
  } else {

  }
  {
#line 62
  hp_slot_ptr->b = 5;
#line 64
  tmp___0 = kzalloc((int )sizeof(*tmp_slot), 1);
#line 64
  tmp_slot = (struct slot *)tmp___0;
  }
#line 66
  if (! tmp_slot) {
#line 67
    rc = -2;
    goto error_no_slot;
  } else {

  }
  {
#line 71
  used_tmp_slot = 0;
#line 72
  freed_tmp_slot = 0;
#line 74
  tmp_slot->a = 2;
#line 75
  tmp_slot->b = 3;
#line 77
  bus_info_ptr1 = ibmphp_find_same_bus_num();
  }
#line 78
  if (! bus_info_ptr1) {
#line 79
    rc = -3;
    goto error;
  } else {

  }
  {
#line 87
  tmp_slot->bus_on = bus_info_ptr1;
#line 88
  bus_info_ptr1 = (struct bus_info *)0;
#line 90
  tmp_slot->hotplug_slot = hp_slot_ptr;
#line 92
  hp_slot_ptr->private = tmp_slot;
#line 93
  used_tmp_slot = 1;
#line 95
  rc = fillslotinfo(hp_slot_ptr);
  }
#line 96
  if (rc) {
    goto error;
  } else {

  }
  {
#line 99
  rc = ibmphp_init_devno(& hp_slot_ptr->private);
  }
#line 100
  if (rc) {
    goto error;
  } else {

  }
#line 103
  return (0);
  error: 
  {
#line 106
  kfree((void *)hp_slot_ptr->private);
  }
  error_no_slot: 
#line 111
  return (rc);
}
}
#line 114 "rule57_ebda_blast-2_BUG.c"
void main(void) 
{ 

  {
  {
#line 115
  ebda_rsrc_controller();
  }
#line 116
  if (! used_tmp_slot) {
#line 117
    if (freed_tmp_slot) {

    } else {
      {
#line 117
      __assert_fail("freed_tmp_slot", "rule57_ebda_blast-2_BUG.c", 117U, "main");
      }
    }
  } else {

  }
#line 118
  return;
}
}
