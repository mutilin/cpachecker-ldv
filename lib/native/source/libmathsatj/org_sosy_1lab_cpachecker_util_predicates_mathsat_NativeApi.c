/*
 * JNI wrapper implementation automatically generated by extract_java_stub.py
 */
#include <stdlib.h>
#include <jni.h>

#include "mathsat.h"

// helper definitions

#define CHECK_FOR_NULL(var) \
  if (var == NULL) { \
    return 0; \
  }

typedef void jvoid; // for symmetry to jint, jlong etc.

// Macros for defining JNI functions which call Mathsat
// Use them as follows:
//
// DEFINE_FUNC(java_return_type, escaped_name_without_msat) WITH_X_ARGS(java_arg_types)
// for each arg a definition like STRUCT_ARG(msat_arg_type, position)
// CALLX(msat_return_type, function_name_without_msat)
// return definition like STRUCT_RETURN depending on the return type

#define DEFINE_FUNC(jreturn,func_escaped) \
  JNIEXPORT j##jreturn JNICALL Java_org_sosy_1lab_cpachecker_util_predicates_mathsat_NativeApi_msat_##func_escaped

#define WITHOUT_ARGS \
  (JNIEnv *jenv, jclass jcls) {

#define WITH_ONE_ARG(jtype) \
  (JNIEnv *jenv, jclass jcls, j##jtype arg1) {

#define WITH_TWO_ARGS(jtype1, jtype2) \
  (JNIEnv *jenv, jclass jcls, j##jtype1 arg1, j##jtype2 arg2) {

#define WITH_THREE_ARGS(jtype1, jtype2, jtype3) \
  (JNIEnv *jenv, jclass jcls, j##jtype1 arg1, j##jtype2 arg2, j##jtype3 arg3) {

#define WITH_FOUR_ARGS(jtype1, jtype2, jtype3, jtype4) \
  (JNIEnv *jenv, jclass jcls, j##jtype1 arg1, j##jtype2 arg2, j##jtype3 arg3, j##jtype4 arg4) {

#define WITH_FIVE_ARGS(jtype1, jtype2, jtype3, jtype4, jtype5) \
  (JNIEnv *jenv, jclass jcls, j##jtype1 arg1, j##jtype2 arg2, j##jtype3 arg3, j##jtype4 arg4, j##jtype5 arg5) {


#define SIMPLE_ARG(mtype, num) \
  mtype m_arg##num = arg##num;

#define STRUCT_ARG(mtype, num) \
  mtype m_arg##num; \
  m_arg##num.repr = (void *)((size_t)arg##num);

#define STRING_ARG(num) \
  char * m_arg##num; \
  m_arg##num = (char *)(*jenv)->GetStringUTFChars(jenv, arg##num, NULL); \
  CHECK_FOR_NULL(m_arg##num)

#define STRUCT_ARRAY_ARG(mtype, num) \
  mtype * m_arg##num; \
  { \
    jlong *tmp = (jlong *)((*jenv)->GetLongArrayElements(jenv, arg##num, NULL)); \
    CHECK_FOR_NULL(tmp) \
    size_t sz = (size_t)((*jenv)->GetArrayLength(jenv, arg##num)); \
    m_arg##num = (mtype *)malloc(sizeof(mtype) * sz); \
    size_t i; \
    for (i = 0; i < sz; ++i) { \
       m_arg##num[i].repr = (void *)((size_t)tmp[i]); \
    } \
    (*jenv)->ReleaseLongArrayElements(jenv, arg##num, tmp, 0); \
  }

#define STRUCT_POINTER_ARG(mtype, num) \
  mtype s_arg##num; \
  mtype * m_arg##num = &s_arg##num;

#define INT_ARRAY_ARG(num) \
  int * m_arg##num = (int *)((*jenv)->GetIntArrayElements(jenv, arg##num, NULL)); \
  CHECK_FOR_NULL(m_arg##num)

#define STRUCT_ARRAY_OUTPUT_ARG(mtype, num) \
  mtype *p_arg##num = NULL; \
  mtype ** m_arg##num = &p_arg##num;


#define CALL0(mreturn, func) mreturn retval = msat_##func();
#define CALL1(mreturn, func) mreturn retval = msat_##func(m_arg1);
#define CALL2(mreturn, func) mreturn retval = msat_##func(m_arg1, m_arg2);
#define CALL3(mreturn, func) mreturn retval = msat_##func(m_arg1, m_arg2, m_arg3);
#define CALL4(mreturn, func) mreturn retval = msat_##func(m_arg1, m_arg2, m_arg3, m_arg4);
#define CALL5(mreturn, func) mreturn retval = msat_##func(m_arg1, m_arg2, m_arg3, m_arg4, m_arg5);
#define VOID_CALL1(func) msat_##func(m_arg1); }


#define FREE_STRING_ARG(num) \
  (*jenv)->ReleaseStringUTFChars(jenv, arg##num, m_arg##num);

#define FREE_STRUCT_ARRAY_ARG(num) \
  free(m_arg##num);

#define FREE_INT_ARRAY_ARG(num) \
  (*jenv)->ReleaseIntArrayElements(jenv, arg##num, m_arg##num, 0);

#define PUT_STRUCT_POINTER_ARG(num) \
  (*jenv)->SetLongArrayRegion(jenv, arg##num, 0, 1, (jlong *)&(s_arg##num.repr));

#define STRUCT_RETURN \
  return (jlong)((size_t)(retval.repr)); \
}

#define SIMPLE_RETURN(jtype) \
  return (j##jtype)retval; \
}

#define STRING_RETURN \
  jstring jretval = (*jenv)->NewStringUTF(jenv, retval); \
  free(retval); \
  return jretval; \
}

#define RETURN_STRUCT_ARRAY(arg_num) \
  jlongArray jretval; \
  if (retval > 0) { \
    jlong *jarr = malloc(sizeof(jlong) * (size_t)retval); \
    int i; \
    for (i = 0; i < (size_t)retval; ++i) { \
        jarr[i] = (jlong)((size_t)p_arg##arg_num[i].repr); \
    } \
    jretval = (*jenv)->NewLongArray(jenv, (size_t)retval); \
    (*jenv)->SetLongArrayRegion(jenv, jretval, 0, (size_t)retval, jarr); \
    free(jarr); \
  } else { \
    jretval = (*jenv)->NewLongArray(jenv, 0); \
  } \
  \
  if (p_arg##arg_num) { \
    free(p_arg##arg_num); \
  } \
  \
  return jretval; \
}


// Abbreviations for common combinations of return and argument types
//
// Parameter explanation:
// func: the name of the Mathsat function (without msat_)
// func_escaped: the escaped variant of func
// jreturn: return type in Java world
// mreturn: return type of Mathsat C function
// margX: Java type of argument X
// jargX: Mathsat type of argument X

#define v_func1s(func,func_escaped,marg1) \
  DEFINE_FUNC(void,func_escaped) WITH_ONE_ARG(long) \
  STRUCT_ARG(marg1, 1) \
  VOID_CALL1(func)

#define func1s(func,func_escaped,jreturn,mreturn,marg1) \
  DEFINE_FUNC(jreturn,func_escaped) WITH_ONE_ARG(long) \
  STRUCT_ARG(marg1, 1) \
  CALL1(mreturn, func) \
  SIMPLE_RETURN(jreturn)

#define s_func1s(func,func_escaped,mreturn,marg1) \
  DEFINE_FUNC(long,func_escaped) WITH_ONE_ARG(long) \
  STRUCT_ARG(marg1, 1) \
  CALL1(mreturn, func) \
  STRUCT_RETURN

#define string_func1s(func,func_escaped,marg1) \
  DEFINE_FUNC(string,func_escaped) WITH_ONE_ARG(long) \
  STRUCT_ARG(marg1, 1) \
  CALL1(char *, func) \
  STRING_RETURN

#define int_func_term(func,func_escaped) \
	func1s(func, func_escaped, \
		int, int, \
		msat_term)


#define func2s(func,func_escaped,jreturn,mreturn,marg1,jarg2,marg2) \
  DEFINE_FUNC(jreturn,func_escaped) WITH_TWO_ARGS(long, jarg2) \
  STRUCT_ARG(marg1, 1) \
  SIMPLE_ARG(marg2, 2) \
  CALL2(mreturn, func) \
  SIMPLE_RETURN(jreturn)

#define s_func2ss(func,func_escaped,mreturn,marg1,marg2) \
  DEFINE_FUNC(long,func_escaped) WITH_TWO_ARGS(long, long) \
  STRUCT_ARG(marg1, 1) \
  STRUCT_ARG(marg2, 2) \
  CALL2(mreturn, func) \
  STRUCT_RETURN

#define string_func2ss(func,func_escaped,marg1,marg2) \
  DEFINE_FUNC(string,func_escaped) WITH_TWO_ARGS(long, long) \
  STRUCT_ARG(marg1, 1) \
  STRUCT_ARG(marg2, 2) \
  CALL2(char *, func) \
  STRING_RETURN

#define s_func2sString(func,func_escaped,mreturn,marg1) \
  DEFINE_FUNC(long,func_escaped) WITH_TWO_ARGS(long, string) \
  STRUCT_ARG(marg1, 1) \
  STRING_ARG(2) \
  CALL2(mreturn, func) \
  FREE_STRING_ARG(2) \
  STRUCT_RETURN


#define s_func3sss(func,func_escaped,mreturn,marg1,marg2,marg3) \
  DEFINE_FUNC(long,func_escaped) WITH_THREE_ARGS(long, long, long) \
  STRUCT_ARG(marg1, 1) \
  STRUCT_ARG(marg2, 2) \
  STRUCT_ARG(marg3, 3) \
  CALL3(mreturn, func) \
  STRUCT_RETURN

// Now really define the functions.

struct j_msat_all_sat_helper {
   JNIEnv *jenv;
   jobject obj;
};

static void call_java_callback(msat_term *model, int size, void *user_data)
{
    struct j_msat_all_sat_helper *helper =
        (struct j_msat_all_sat_helper *)user_data;

    const char *signature = "([J)V";
    jclass cls = (*(helper->jenv))->FindClass(helper->jenv,
                                              "org/sosy_lab/cpachecker/util/predicates/mathsat/NativeApi$AllSatModelCallback");
    jmethodID mid = (*(helper->jenv))->GetMethodID(helper->jenv, cls,
                                                   "callback", signature);    
        
    jlongArray jmodel = (*(helper->jenv))->NewLongArray(helper->jenv,
                                                        (size_t)size);
    jlong *jarr = malloc(sizeof(jlong) * size);
    int i;
    for (i = 0; i < size; ++i) {
        jarr[i] = (jlong)((size_t)model[i].repr);
    }
    (*(helper->jenv))->SetLongArrayRegion(helper->jenv, jmodel, 0, (size_t)size,
                                          (jlong *)jarr);

    (*(helper->jenv))->CallVoidMethod(helper->jenv, helper->obj, mid, jmodel);
    free(jarr);
}


DEFINE_FUNC(void, 1set_1verbosity) WITH_ONE_ARG(int)
SIMPLE_ARG(int, 1)
VOID_CALL1(set_verbosity)


DEFINE_FUNC(long, 1create_1env) WITHOUT_ARGS
CALL0(msat_env, create_env)
STRUCT_RETURN


s_func1s(create_shared_env, 1create_1shared_1env, \
	msat_env, \
	msat_env)

v_func1s(reset_env, 1reset_1env, \
	msat_env)

v_func1s(destroy_env, 1destroy_1env, \
	msat_env)


DEFINE_FUNC(int, 1set_1option) WITH_THREE_ARGS(long, string, string)
STRUCT_ARG(msat_env, 1)
STRING_ARG(2)
STRING_ARG(3)
CALL3(int, set_option)
FREE_STRING_ARG(3)
FREE_STRING_ARG(2)
SIMPLE_RETURN(int)


DEFINE_FUNC(long, 1declare_1variable) WITH_THREE_ARGS(long, string, int)
STRUCT_ARG(msat_env, 1)
STRING_ARG(2)
SIMPLE_ARG(msat_type, 3)
CALL3(msat_decl, declare_variable)
FREE_STRING_ARG(2)
STRUCT_RETURN


DEFINE_FUNC(long, 1declare_1uif) WITH_FIVE_ARGS(long, string, int, int, intArray)
STRUCT_ARG(msat_env, 1)
STRING_ARG(2)
SIMPLE_ARG(msat_type, 3)
SIMPLE_ARG(int, 4)
INT_ARRAY_ARG(5)
CALL5(msat_decl, declare_uif)
FREE_INT_ARRAY_ARG(5)
FREE_STRING_ARG(2)
STRUCT_RETURN


s_func1s(make_true, 1make_1true, \
	msat_term, \
	msat_env)

s_func1s(make_false, 1make_1false, \
	msat_term, \
	msat_env)

#define make_term_binary(name) \
	s_func3sss(make_##name, 1make_1##name, \
		msat_term, \
		msat_env, \
		msat_term, \
		msat_term)

make_term_binary(iff)
make_term_binary(implies)
make_term_binary(or)
make_term_binary(xor)

s_func2ss(make_not, 1make_1not, \
	msat_term, \
	msat_env, \
	msat_term)

make_term_binary(and)
make_term_binary(equal)
make_term_binary(lt)
make_term_binary(gt)
make_term_binary(leq)
make_term_binary(geq)
make_term_binary(plus)
make_term_binary(minus)
make_term_binary(times)

s_func2ss(make_negate, 1make_1negate, \
	msat_term, \
	msat_env, \
	msat_term)

s_func2sString(make_number, 1make_1number, \
	msat_term,
	msat_env)


DEFINE_FUNC(long, 1make_1ite) WITH_FOUR_ARGS(long, long, long, long)
STRUCT_ARG(msat_env, 1)
STRUCT_ARG(msat_term, 2)
STRUCT_ARG(msat_term, 3)
STRUCT_ARG(msat_term, 4)
CALL4(msat_term, make_ite)
STRUCT_RETURN


s_func2ss(make_variable, 1make_1variable, \
	msat_term, \
	msat_env, \
	msat_decl)


DEFINE_FUNC(long, 1make_1uif) WITH_THREE_ARGS(long, long, longArray)
STRUCT_ARG(msat_env, 1)
STRUCT_ARG(msat_decl, 2)
STRUCT_ARRAY_ARG(msat_term, 3)
CALL3(msat_term, make_uif)
FREE_STRUCT_ARRAY_ARG(3)
STRUCT_RETURN


#define make_term_bv_binary(name) \
	s_func3sss(make_bv_##name, 1make_1bv_1##name, \
		msat_term, \
		msat_env, \
		msat_term, \
		msat_term)

make_term_bv_binary(concat)
make_term_bv_binary(or)
make_term_bv_binary(xor)
make_term_bv_binary(and)
make_term_bv_binary(lsl)
make_term_bv_binary(lsr)
make_term_bv_binary(asr)
make_term_bv_binary(plus)
make_term_bv_binary(minus)
make_term_bv_binary(times)
make_term_bv_binary(udiv)
make_term_bv_binary(urem)
make_term_bv_binary(sdiv)
make_term_bv_binary(srem)
make_term_bv_binary(smod)
make_term_bv_binary(ult)
make_term_bv_binary(uleq)
make_term_bv_binary(ugt)
make_term_bv_binary(ugeq)
make_term_bv_binary(slt)
make_term_bv_binary(sleq)
make_term_bv_binary(sgt)
make_term_bv_binary(sgeq)

s_func2sString(from_string, 1from_1string, \
	msat_term,
	msat_env)


DEFINE_FUNC(long, 1from_1string_1and_1name) WITH_THREE_ARGS(long, string, string)
STRUCT_ARG(msat_env, 1)
STRING_ARG(2)
STRING_ARG(3)
CALL3(msat_term, from_string_and_name)
FREE_STRING_ARG(3)
FREE_STRING_ARG(2)
STRUCT_RETURN


s_func3sss(make_copy_from, 1make_1copy_1from, \
	msat_term, \
	msat_env, \
	msat_term, \
	msat_env)


DEFINE_FUNC(long, 1replace_1args) WITH_THREE_ARGS(long, long, longArray)
STRUCT_ARG(msat_env, 1)
STRUCT_ARG(msat_term, 2)
STRUCT_ARRAY_ARG(msat_term, 3)
CALL3(msat_term, replace_args)
FREE_STRUCT_ARRAY_ARG(3)
STRUCT_RETURN


s_func2sString(from_msat, 1from_1msat, \
	msat_term,
	msat_env)

s_func2sString(from_smt, 1from_1smt, \
	msat_term,
	msat_env)

s_func2sString(from_foci, 1from_1foci, \
	msat_term,
	msat_env)

string_func2ss(to_msat, 1to_1msat, \
	msat_env, \
	msat_term)

string_func2ss(to_smtlib, 1to_1smtlib, \
	msat_env, \
	msat_term)

int_func_term(term_id, 1term_1id)
int_func_term(term_arity, 1term_1arity)


DEFINE_FUNC(long, 1term_1get_1arg) WITH_TWO_ARGS(long, int) \
STRUCT_ARG(msat_term, 1) \
SIMPLE_ARG(int, 2) \
CALL2(msat_term, term_get_arg) \
STRUCT_RETURN


int_func_term(term_get_type, 1term_1get_1type)

#define func_term_is(name) int_func_term(term_is_##name, 1term_1is_1##name)
func_term_is(true)
func_term_is(false)
int_func_term(term_is_boolean_var, 1term_1is_1boolean_1var)
func_term_is(atom)
func_term_is(number)
func_term_is(and)
func_term_is(or)
func_term_is(not)
func_term_is(iff)
func_term_is(implies)
func_term_is(xor)
int_func_term(term_is_bool_ite, 1term_1is_1bool_1ite)
int_func_term(term_is_term_ite, 1term_1is_1term_1ite)
func_term_is(variable)
func_term_is(uif)
func_term_is(equal)
func_term_is(lt)
func_term_is(leq)
func_term_is(gt)
func_term_is(geq)
func_term_is(plus)
func_term_is(minus)
func_term_is(times)
func_term_is(negate)

#define func_term_is_bv(name) int_func_term(term_is_bv_##name, 1term_1is_1bv_1##name)
func_term_is_bv(concat)
func_term_is_bv(select)
func_term_is_bv(or)
func_term_is_bv(xor)
func_term_is_bv(and)
func_term_is_bv(not)
func_term_is_bv(lsl)
func_term_is_bv(lsr)
func_term_is_bv(asr)
func_term_is_bv(zext)
func_term_is_bv(sext)
func_term_is_bv(plus)
func_term_is_bv(minus)
func_term_is_bv(times)
func_term_is_bv(udiv)
func_term_is_bv(urem)
func_term_is_bv(sdiv)
func_term_is_bv(srem)
func_term_is_bv(smod)
func_term_is_bv(ult)
func_term_is_bv(uleq)
func_term_is_bv(ugt)
func_term_is_bv(ugeq)
func_term_is_bv(slt)
func_term_is_bv(sleq)
func_term_is_bv(sgt)
func_term_is_bv(sgeq)

s_func1s(term_get_decl, 1term_1get_1decl, \
	msat_decl, \
	msat_term)

func1s(decl_get_return_type, 1decl_1get_1return_1type, \
	int, msat_type, \
	msat_decl)

func1s(decl_get_arity, 1decl_1get_1arity, \
	int, int,
	msat_decl)

func2s(decl_get_arg_type, 1decl_1get_1arg_1type, \
	int, msat_type, \
	msat_decl, \
	int, int)

string_func1s(decl_get_name, 1decl_1get_1name, \
	msat_decl)

string_func2ss(term_get_name, 1term_1get_1name, \
	msat_env, \
	msat_term)

string_func1s(term_repr, 1term_1repr, \
	msat_term)

func2s(add_theory, 1add_1theory, \
	int, int, \
	msat_env, \
	int, msat_theory)

func2s(set_theory_combination, 1set_1theory_1combination, \
	int, int, \
	msat_env, \
	int, msat_theory_combination)

func1s(push_backtrack_point, 1push_1backtrack_1point, \
	int, int, \
	msat_env)

func1s(pop_backtrack_point, 1pop_1backtrack_1point, \
	int, int, \
	msat_env)


DEFINE_FUNC(int, 1assert_1formula) WITH_TWO_ARGS(long, long) \
STRUCT_ARG(msat_env, 1) \
STRUCT_ARG(msat_term, 2)
CALL2(int, assert_formula) \
SIMPLE_RETURN(int)


func1s(solve, 1solve, \
	int, msat_result, \
	msat_env)


DEFINE_FUNC(int, 1all_1sat) WITH_FIVE_ARGS(long, longArray, int, object, int)
STRUCT_ARG(msat_env, 1)
STRUCT_ARRAY_ARG(msat_term, 2)
SIMPLE_ARG(int, 3)
    struct j_msat_all_sat_helper helper = {jenv, arg4};
    int retval = msat_all_sat(m_arg1, m_arg2, m_arg3, call_java_callback, &helper);
FREE_STRUCT_ARRAY_ARG(2)
SIMPLE_RETURN(int)


s_func2ss(get_model_value, 1get_1model_1value, \
	msat_term, \
	msat_env, \
	msat_term)

s_func1s(create_model_iterator, 1create_1model_1iterator, \
	msat_model_iterator, \
	msat_env)

func1s(model_iterator_has_next, 1model_1iterator_1has_1next, \
	int, int, \
	msat_model_iterator)


DEFINE_FUNC(int, 1model_1iterator_1next) WITH_THREE_ARGS(long, longArray, longArray)
STRUCT_ARG(msat_model_iterator, 1)
STRUCT_POINTER_ARG(msat_term, 2)
STRUCT_POINTER_ARG(msat_term, 3)
CALL3(int, model_iterator_next)
PUT_STRUCT_POINTER_ARG(3)
PUT_STRUCT_POINTER_ARG(2)
SIMPLE_RETURN(int)



v_func1s(destroy_model_iterator, 1destroy_1model_1iterator, \
	msat_model_iterator)


DEFINE_FUNC(longArray, 1get_1theory_1lemmas) WITH_TWO_ARGS(long, int)
STRUCT_ARG(msat_env, 1)
STRUCT_ARRAY_OUTPUT_ARG(msat_term, 2)
CALL2(int, get_theory_lemmas)
RETURN_STRUCT_ARRAY(2)

s_func1s(get_unsat_core, 1get_1unsat_1core, \
	msat_term, \
	msat_env)

func1s(init_interpolation, 1init_1interpolation, \
	int, int,
	msat_env)

func1s(create_itp_group, 1create_1itp_1group, \
	int, int,
	msat_env)

func2s(set_itp_group, 1set_1itp_1group, \
	int, int, \
	msat_env, \
	int, int)

DEFINE_FUNC(long, 1get_1interpolant) WITH_THREE_ARGS(long, intArray, int)
STRUCT_ARG(msat_env, 1)
INT_ARRAY_ARG(2)
SIMPLE_ARG(size_t, 3)
CALL3(msat_term, get_interpolant)
FREE_INT_ARRAY_ARG(2)
STRUCT_RETURN
