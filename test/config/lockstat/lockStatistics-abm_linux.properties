# reverse postorder (a more restrictive topological ordering) is better than dfs if elements may be merged
analysis.traversal.order = bfs
analysis.traversal.useReversePostorder = true
# analysis.traversal.useReversePostorder = false
analysis.traversal.useCallstack = true
# analysis.traversal.useCallstack = false
analysis.functionPointerCalls = false
precision.path = localsave
analysis.reachedSet = USAGESTATISTICS

# analysis.useCBMC = true
# analysis.useRefinement = true

analysis.entryFunction = ldv_main

cpa.arg.export = false
cpa.arg.errorPath.export = false

output.disable = true
analysis.algorithm.CEGAR = true
cpa.callstack.skipRecursion = true

coverage.output = coverage.info

# parser.dialect = GNUC

# cpa.predicate.solver=SMTInterpol

# cegar.refiner = cpa.predicate.ABMPredicateRefiner

# ARGCPA is necessary for refinement and has to be the top-level CPA
cpa = cpa.bam.BAMCPA

BAMCPA.cpa = cpa.arg.ARGCPA

ARGCPA.cpa = cpa.usagestatistics.UsageStatisticsCPA

UsageStatisticsCPA.cpa = cpa.composite.CompositeCPA

CompositeCPA.cpas = cpa.location.LocationCPA, cpa.callstack.CallstackCPA, cpa.lockstatistics.LockStatisticsCPA, cpa.predicate.BAMPredicateCPA
cegar.refiner = cpa.usagestatistics.UsageStatisticsRefiner
cegar.refinementLoops = 0

# this automaton defines which locations are the error locations
# specification = config/specification/default.spc

cpa.abm.blockHeuristic = FunctionPartitioning
cpa.abm.gatherCacheMissStatistics = false
cpa.abm.aggressiveCaching = false

# Set time limit to 15 minutes
# cpa.conditions.global.time.wall = 15min

cpa.lockStatistics.lockinfo = mutex_lock, spin_lock

# mutex_lock.lock = mutex_lock, mutex_lock_nested
# mutex_lock.mutex_lock_nested.parameters = 1
# mutex_lock.mutex_lock.parameters = 1
# mutex_lock.unlock = mutex_unlock
# mutex_lock.mutex_unlock.parameters = 1
mutex_lock.lock = ldv_mutex_lock
mutex_lock.ldv_mutex_lock.parameters = 2
mutex_lock.unlock = ldv_mutex_unlock
mutex_lock.ldv_mutex_unlock.parameters = 2
mutex_lock.maxDepth = 2

# spin_lock.lock = __ldv_spin_lock
# spin_lock.unlock = __ldv_spin_unlock
spin_lock.lock = ldv_spin_lock
spin_lock.ldv_spin_lock.parameters = 2
spin_lock.unlock = ldv_spin_unlock
spin_lock.ldv_spin_unlock.parameters = 2
spin_lock.maxDepth = 2

# cpa.lockStatistics.lockreset = lockreset

cpa.usagestatistics.output = unsafe_rawdata
cpa.usagestatistics.abortfunctions = __exit, pthread_exit, HealthMonitor, panic

# cpa.usagestatistics.fullstatistics = false

cpa.usagestatistics.unsafeDetectorType = PAIR

# cpa.usagestatistics.onlypointers = false

cpa.usagestatistics.binderFunctions = sdlFirst, sdlInsert, sdlNext, memNODE_TO_HDR, memHDR_TO_NODE, memNEXT_HDR, memPREV_HDR, memHDR_TO_BLK, memBLK_TO_HDR, sdlExtractNext, sdlExtract, sdlAppend, ddlExtract, ddlGetFirst, ddlAppend, ddlMove, ddlInit, ddlInsert, sdlGetFirst, sdlInitEmpty, memREGION_ADDRESS, mfree_annotated

cpa.usagestatistics.unsafedetector.detectByReadAccess = threadNestLevel

cpa.usagestatistics.localanalysis = true

cpa.usagestatistics.unsafedetector.ignoreEmptyLockset = true

# cpa.usagestatistics.skippedvariables.byName = errno
cpa.usagestatistics.skippedvariables.byType = struct ath_tx_stats

sdlFirst.parameters = 1
sdlFirst.pInfo = READ:1
sdlFirst.linkInfo = 0, 1

sdlInsert.parameters = 3
sdlInsert.pInfo = WRITE:1, WRITE:1, WRITE:1

sdlNext.parameters = 1
sdlNext.pInfo = READ:1
sdlNext.linkInfo = 0, 1

sdlInitEmpty.parameters = 1
sdlInitEmpty.pInfo = WRITE:1

memNODE_TO_HDR.parameters = 1
memNODE_TO_HDR.pInfo = READ:1
memNODE_TO_HDR.linkInfo = 0, 1

memHDR_TO_NODE.parameters = 1
memHDR_TO_NODE.pInfo = READ:0
memHDR_TO_NODE.linkInfo = 0, 1

memNEXT_HDR.parameters = 1
memNEXT_HDR.pInfo = READ:0
memNEXT_HDR.linkInfo = 0, 1

memPREV_HDR.parameters = 1
memPREV_HDR.pInfo = READ:1
memPREV_HDR.linkInfo = 0, 1

memHDR_TO_BLK.parameters = 1
memHDR_TO_BLK.pInfo = READ:0
memHDR_TO_BLK.linkInfo = 0, 1

memBLK_TO_HDR.parameters = 1
memBLK_TO_HDR.pInfo = READ:0
memBLK_TO_HDR.linkInfo = 0, 1

memREGION_ADDRESS.parameters = 2
memREGION_ADDRESS.pInfo = READ, READ

sdlExtractNext.parameters = 2
sdlExtractNext.pInfo = WRITE:1, WRITE:1

sdlExtract.parameters = 2
sdlExtract.pInfo = WRITE:1, READ:1

sdlAppend.parameters = 2
sdlAppend.pInfo = WRITE:1, WRITE:1

sdlGetFirst.parameters = 1
sdlGetFirst.pInfo = WRITE:1
sdlGetFirst.linkInfo = 0, 1

ddlExtract.parameters = 1
ddlExtract.pInfo = WRITE:1

ddlGetFirst.parameters = 1
ddlGetFirst.pInfo = WRITE:1
ddlGetFirst.linkInfo = 0, 1

ddlInsert.parameters = 2
ddlInsert.pInfo = WRITE:1, WRITE:1

ddlAppend.parameters = 2
ddlAppend.pInfo = WRITE:1, WRITE:1

ddlMove.parameters = 2
ddlMove.pInfo = WRITE:1, WRITE:1
ddlMove.linkInfo = 1, 2

ddlInit.parameters = 4
ddlInit.pInfo = WRITE:1, READ:1, READ:0, READ:0

mfree_annotated.parameters = 2
mfree_annotated.pInfo = WRITE:1, WRITE:1

# cpa.lockStatistics.functionhandler = OS

cpa.usagestatistics.covering = true

cpa.usagestatistics.skippedfunctions = sdlFirst, sdlInsert, sdlNext, memNODE_TO_HDR, memHDR_TO_NODE, memNEXT_HDR, memPREV_HDR, memHDR_TO_BLK, memBLK_TO_HDR, sdlExtractNext, sdlExtract, sdlAppend, ddlExtract, ddlGetFirst, ddlAppend, sdlGetFirst, sdlInitEmpty, memREGION_ADDRESS, mfree_annotated

# log.consoleLevel = ALL
#include predicateAnalysis.properties
