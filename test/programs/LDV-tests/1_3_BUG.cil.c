/* Generated by CIL v. 1.3.7 */
/* print_CIL_Input is true */

#line 3 "1_3.h"
struct RR {
   int state ;
};
#line 8 "1_3.h"
typedef struct RR rr;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void __assert_fail(char const   *__assertion ,
                                                                      char const   *__file ,
                                                                      unsigned int __line ,
                                                                      char const   *__function ) ;
#line 10 "1_3.h"
extern rr *__undefrr() ;
#line 4 "1_3_BUG.c"
int VERDICT_UNSAFE  ;
#line 5 "1_3_BUG.c"
int CURRENTLY_SAFE  ;
#line 13 "1_3_BUG.c"
rr *getrr(void) 
{ rr *r ;
  rr *tmp ;

  {
  {
#line 15
  tmp = __undefrr();
#line 15
  r = tmp;
#line 16
  r->state = 0;
  }
#line 17
  return (r);
}
}
#line 20 "1_3_BUG.c"
rr *getPtr(void) 
{ rr *r ;
  rr *tmp ;

  {
  {
#line 22
  tmp = getrr();
#line 22
  r = tmp;
#line 23
  r->state = 1;
  }
#line 24
  return (r);
}
}
#line 27 "1_3_BUG.c"
void freePtr(rr *ptr ) 
{ 

  {
#line 29
  if (ptr->state == 1) {

  } else {
    {
#line 29
    __assert_fail("ptr -> state == 1", "1_3_BUG.c", 29U, "freePtr");
    }
  }
#line 30
  ptr->state = 2;
#line 31
  return;
}
}
#line 33 "1_3_BUG.c"
int main(void) 
{ rr *ptr1 ;

  {
  {
#line 35
  ptr1 = (rr *)0;
#line 36
  ptr1 = getPtr();
#line 37
  freePtr(ptr1);
#line 38
  freePtr(ptr1);
  }
#line 40
  return (0);
}
}
